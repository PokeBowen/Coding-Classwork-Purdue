#STAT 545
#Example R code for grade calculation
#Need to make sure "scores.csv" is present in the directory where R is invoked
#Clear the workspace
rm(list=ls())
#reading a data frame from an Excel file
score=read.csv("scores.csv", header =T)
is.data.frame(score)
score
#unsubmitted hw/quiz/exam/project counts as 0 score
score[is.na(score)] = 0
score
#Calculate component-wise scores according to the syllabus
hw.component = (score$HW_maxscore_100/100)*30
midterm.component = (score$Midterm_maxscore_50/50)*25
final.component = (score$Final_maxscore_50/50)*25
project.component=(score$Project_maxscore_100/100)*20
#Calculate total score
total = cbind(hw.component, midterm.component, final.component, project.component)
totalscore = apply(total,1,sum)
#Assign grades
grades = rep(NA,nrow(score))
for ( i in 1:nrow(score)){
if (totalscore[i]< 59) grades[i] = "F"
else if ((totalscore[i]>= 60) & (totalscore [i] <70)) grades[i] = "D"
else if ((totalscore[i]>= 70) & (totalscore [i] < 80)) grades[i] = "C"
else if ((totalscore[i]>= 80) & (totalscore [i] < 90)) grades[i] = "B"
else if ((totalscore[i]>= 90) & (totalscore [i] <100)) grades[i] = "A"
else grades[i] = "ERROR"
}
#bind the final score and letter grade together
finalscore = cbind(score, grades)
finalscore
score
finalscore
#STAT 545
#Example R code for grade calculation
#Need to make sure "scores.csv" is present in the directory where R is invoked
#Clear the workspace
rm(list=ls())
#reading a data frame from an Excel file
score=read.csv("scores_new.csv", header =T)
is.data.frame(score)
#unsubmitted hw/quiz/exam/project counts as 0 score
score[is.na(score)] = 0
#Calculate HW total
score$HW_maxscore_100 = score$HW_1 + score$HW_2 + score$HW_3 + score$HW_4 + score$HW_5
#Calculate component-wise scores according to each equal
hw.component = (score$HW_maxscore_100/100)*25
midterm.component = (score$Midterm_maxscore_50/50)*25
final.component = (score$Final_maxscore_50/50)*25
project.component=(score$Project_maxscore_100/100)*25
#Calculate total score
total = cbind(hw.component, midterm.component, final.component, project.component)
totalscore = apply(total,1,sum)
#Assign grades
grades = rep(NA,nrow(score))
for ( i in 1:nrow(score)){
if (totalscore[i]< 59) grades[i] = "F"
else if ((totalscore[i]>= 60) & (totalscore [i] <70)) grades[i] = "D"
else if ((totalscore[i]>= 70) & (totalscore [i] < 80)) grades[i] = "C"
else if ((totalscore[i]>= 80) & (totalscore [i] < 90)) grades[i] = "B"
else if ((totalscore[i]>= 90) & (totalscore [i] <100)) grades[i] = "A"
else grades[i] = "ERROR"
}
finalscore = cbind(score, grades)
finalscore
score
finalscore
# Clear the workspace
rm(list=ls())
# Reading a data frame from an Excel file
score=read.csv("scores_new.csv", header =T)
# Simply use apply and median with na.rm=TRUE to find our homework medians
# First select the columns we want to use
hw_cols <- c("HW_1", "HW_2", "HW_3", "HW_4", "HW_5")
hw_medians = apply(score[, hw_cols], 2, median, na.rm = TRUE)
print(hw_medians)
# Let us only look at Alice's row
alice_row = score[score$First.Name == "Alice", ]
# Calculate median (using same hw columns as before)
alice_median = median(as.numeric(alice_row[, hw_cols]), na.rm = TRUE)
print(alice_median)
# Clear the workspace
rm(list=ls())
# Reading a data frame from an Excel file
score=read.csv("scores_new.csv", header =T)
# Simply use apply and median with na.rm=TRUE to find our student medians
# First select the columns we want to use
hw_cols <- c("HW_1", "HW_2", "HW_3", "HW_4", "HW_5")
student_medians = apply(score[, hw_cols], 1, median, na.rm = TRUE)
# Add scores to data using column bind
score_with_medians = cbind(score, Median_HW = student_medians)
# Now we sort using order
score_with_medians_final <- score_with_medians[order(score_with_medians$Median_HW, decreasing = TRUE), ]
print(score_with_medians)
print(score_with_medians_final)
#STAT 545
#Example R code for grade calculation
#Need to make sure "scores.csv" is present in the directory where R is invoked
#Clear the workspace
rm(list=ls())
#reading a data frame from an Excel file
score=read.csv("scores.csv", header =T)
is.data.frame(score)
score
#unsubmitted hw/quiz/exam/project counts as 0 score
score[is.na(score)] = 0
score
#Calculate component-wise scores according to the syllabus
hw.component = (score$HW_maxscore_100/100)*30
midterm.component = (score$Midterm_maxscore_50/50)*25
final.component = (score$Final_maxscore_50/50)*25
project.component=(score$Project_maxscore_100/100)*20
#Calculate total score
total = cbind(hw.component, midterm.component, final.component, project.component)
totalscore = apply(total,1,sum)
#Assign grades
grades = rep(NA,nrow(score))
for ( i in 1:nrow(score)){
if (totalscore[i]< 59) grades[i] = "F"
else if ((totalscore[i]>= 60) & (totalscore [i] <70)) grades[i] = "D"
else if ((totalscore[i]>= 70) & (totalscore [i] < 80)) grades[i] = "C"
else if ((totalscore[i]>= 80) & (totalscore [i] < 90)) grades[i] = "B"
else if ((totalscore[i]>= 90) & (totalscore [i] <100)) grades[i] = "A"
else grades[i] = "ERROR"
}
#bind the final score and letter grade together
finalscore = cbind(score, grades)
finalscore
score
finalscore
#STAT 545
#Example R code for grade calculation
#Need to make sure "scores.csv" is present in the directory where R is invoked
#Clear the workspace
rm(list=ls())
#reading a data frame from an Excel file
score=read.csv("scores_new.csv", header =T)
is.data.frame(score)
#unsubmitted hw/quiz/exam/project counts as 0 score
score[is.na(score)] = 0
#Calculate HW total
score$HW_maxscore_100 = score$HW_1 + score$HW_2 + score$HW_3 + score$HW_4 + score$HW_5
#Calculate component-wise scores according to each equal
hw.component = (score$HW_maxscore_100/100)*25
midterm.component = (score$Midterm_maxscore_50/50)*25
final.component = (score$Final_maxscore_50/50)*25
project.component=(score$Project_maxscore_100/100)*25
#Calculate total score
total = cbind(hw.component, midterm.component, final.component, project.component)
totalscore = apply(total,1,sum)
#Assign grades
grades = rep(NA,nrow(score))
for ( i in 1:nrow(score)){
if (totalscore[i]< 59) grades[i] = "F"
else if ((totalscore[i]>= 60) & (totalscore [i] <70)) grades[i] = "D"
else if ((totalscore[i]>= 70) & (totalscore [i] < 80)) grades[i] = "C"
else if ((totalscore[i]>= 80) & (totalscore [i] < 90)) grades[i] = "B"
else if ((totalscore[i]>= 90) & (totalscore [i] <100)) grades[i] = "A"
else grades[i] = "ERROR"
}
finalscore = cbind(score, grades)
finalscore
score
finalscore
# Clear the workspace
rm(list=ls())
# Reading a data frame from an Excel file
score=read.csv("scores_new.csv", header =T)
# Simply use apply and median with na.rm=TRUE to find our homework medians
# First select the columns we want to use
hw_cols <- c("HW_1", "HW_2", "HW_3", "HW_4", "HW_5")
hw_medians = apply(score[, hw_cols], 2, median, na.rm = TRUE)
print(hw_medians)
# Let us only look at Alice's row
alice_row = score[score$First.Name == "Alice", ]
# Calculate median (using same hw columns as before)
alice_median = median(as.numeric(alice_row[, hw_cols]), na.rm = TRUE)
print(alice_median)
# Clear the workspace
rm(list=ls())
# Reading a data frame from an Excel file
score=read.csv("scores_new.csv", header =T)
# Simply use apply and median with na.rm=TRUE to find our student medians
# First select the columns we want to use
hw_cols <- c("HW_1", "HW_2", "HW_3", "HW_4", "HW_5")
student_medians = apply(score[, hw_cols], 1, median, na.rm = TRUE)
# Add scores to data using column bind
score_with_medians = cbind(score, Median_HW = student_medians)
# Now we sort using order
score_with_medians_final <- score_with_medians[order(score_with_medians$Median_HW, decreasing = TRUE), ]
print(score_with_medians)
print(score_with_medians_final)
### Need to load faraway package to have access to data sets and
### several functions
install.packages("faraway")
install.packages("car")
library(faraway)
data(gavote)
### Lists the first 6 datalines of the data set
head(gavote)
### Summarizes the structure of the data set
str(gavote)
### Get summary statistics for each of the variables
summary(gavote)
### Because number of votes highly skewed, will look at percent undercount
percunder <- (gavote$ballots - gavote$votes)/gavote$ballots
### Generate histogram of percent undercount
hist(percunder,xlab="Percent",las=1,main="Undercount")
### Generate density with data shown at bottom
plot(density(percunder),main="Percent Undercount",las=1)
rug(percunder)
### Define new percent variables for Gore and Bush votes
pergore = gavote$gore/gavote$votes
perbush = gavote$bush/gavote$votes
### Generate a scatterplot matrix of numeric variables
pairs(~percunder+gavote$perAA+pergore+perbush,pch=20)
### Generate side-by-side boxplots
plot(percunder~rural,gavote,las=1,ylab="Percent")
plot(percunder~equip,gavote,las=1)
###Fitting a linear model using the lm function
model1 = lm(percunder ~ pergore + perAA, gavote)
###Obtain summary information from model fit
summary(model1)
###Reduced summary information function proposed by Faraway
sumary(model1)
###Requesting ANOVA Table but be wary this is using Type I SS
anova(model1)
### This library contains function allowing Type III SS.  Be wary
### of its use too.  Often need to change options using
options(contrasts = c("contr.sum", "contr.poly"))
library(car)
Anova(model1, type=3)
### Generate a 2x2 panel of diagnostic plots
par(mar=c(2,2,2,2),mfrow=c(2,2))
plot(model1,cex=0.65,cex.axis=0.7,cex.lab=0.5)
### Creating centered variables.  Can help with multicolinearity when
### considering polynomials and interactions
cpergore = pergore - mean(pergore)
cperAA = gavote$perAA - mean(gavote$perAA)
### Fitting alternative model
model2 = lm(percunder ~ cperAA+cpergore*rural+equip, gavote)
sumary(model2)
### General linear test comparing the two models
anova(model1,model2)
### Consider dropping single predictors.  Again performing general linear test
drop1(model2,test="F")
### New model dropping insignificant terms from previous function
model3 = lm(percunder ~ cpergore+rural+equip, gavote)
sumary(model3)
anova(model2,model3)
### Defining maximum model from which to select from
modelmax = lm(percunder ~ (equip+econ+rural+atlanta)^2 + (equip+econ+rural+atlanta)*(pergore+perAA), gavote)
### Using AIC to reduce model
modelbest = step(modelmax,trace=FALSE)
summary(modelbetter)
### Need to load faraway package to have access to data sets and
### several functions
install.packages("faraway")
### Need to load faraway package to have access to data sets and
### several functions
install.packages("faraway")
install.packages("car")
library(faraway)
data(gavote)
### Lists the first 6 datalines of the data set
head(gavote)
### Summarizes the structure of the data set
str(gavote)
### Get summary statistics for each of the variables
summary(gavote)
### Because number of votes highly skewed, will look at percent undercount
percunder <- (gavote$ballots - gavote$votes)/gavote$ballots
### Generate histogram of percent undercount
hist(percunder,xlab="Percent",las=1,main="Undercount")
### Generate density with data shown at bottom
plot(density(percunder),main="Percent Undercount",las=1)
rug(percunder)
### Define new percent variables for Gore and Bush votes
pergore = gavote$gore/gavote$votes
perbush = gavote$bush/gavote$votes
### Generate a scatterplot matrix of numeric variables
pairs(~percunder+gavote$perAA+pergore+perbush,pch=20)
### Generate side-by-side boxplots
plot(percunder~rural,gavote,las=1,ylab="Percent")
plot(percunder~equip,gavote,las=1)
###Fitting a linear model using the lm function
model1 = lm(percunder ~ pergore + perAA, gavote)
###Obtain summary information from model fit
summary(model1)
###Reduced summary information function proposed by Faraway
sumary(model1)
###Requesting ANOVA Table but be wary this is using Type I SS
anova(model1)
### This library contains function allowing Type III SS.  Be wary
### of its use too.  Often need to change options using
options(contrasts = c("contr.sum", "contr.poly"))
library(car)
Anova(model1, type=3)
### Generate a 2x2 panel of diagnostic plots
par(mar=c(2,2,2,2),mfrow=c(2,2))
plot(model1,cex=0.65,cex.axis=0.7,cex.lab=0.5)
### Creating centered variables.  Can help with multicolinearity when
### considering polynomials and interactions
cpergore = pergore - mean(pergore)
cperAA = gavote$perAA - mean(gavote$perAA)
### Fitting alternative model
model2 = lm(percunder ~ cperAA+cpergore*rural+equip, gavote)
sumary(model2)
### General linear test comparing the two models
anova(model1,model2)
### Consider dropping single predictors.  Again performing general linear test
drop1(model2,test="F")
### New model dropping insignificant terms from previous function
model3 = lm(percunder ~ cpergore+rural+equip, gavote)
sumary(model3)
anova(model2,model3)
### Defining maximum model from which to select from
modelmax = lm(percunder ~ (equip+econ+rural+atlanta)^2 + (equip+econ+rural+atlanta)*(pergore+perAA), gavote)
### Using AIC to reduce model
modelbest = step(modelmax,trace=FALSE)
summary(modelbest)
drop1(modelbest,test="F")
### Determing best model
modelbetter2 = lm(percunder ~ equip+econ+rural+perAA+equip:econ+equip:perAA, gavote)
drop1(modelbetter2,test="F")
sumary(modelbetter2)
### Getting tables of predictions
pdf <- data.frame(econ=rep(levels(gavote$econ),5),equip=rep(levels(gavote$equip), rep(3,5)), perAA=0.233, rural="rural")
ppr = predict(modelbetter2,new=pdf)
xtabs(round(ppr,3)~econ+equip,pdf)
pdf <- data.frame(econ=rep(levels(gavote$econ),5),equip=rep(levels(gavote$equip), rep(3,5)), perAA=0.233, rural="urban")
ppu = predict(modelbetter2,new=pdf)
xtabs(round(ppu,3)~econ+equip,pdf)
tinytex::tlmgr_install("pdfcrop")
View(modelbetter2)
stop
no
View(modelbest)
model_wls <- update(modelbetter2, weights = ballots, data = gavote)
summary(model_wls)
View(gavote)
model_wls <- update(modelbetter2, weights = ballots, data = gavote)
summary(model_wls)
par(mfrow=c(1,2))
plot(modelbetter2, which = 3, main = "OLS (Heteroscedasticity)")
plot(model_wls, which = 3, main = "WLS (Standardized)")
View(gavote)
w <- percunder*(1-percunder)/gavote$ballots
model_wls <- update(modelbetter2, weights = w, data = gavote)
summary(model_wls)
par(mfrow=c(1,2))
plot(modelbetter2, which = 3, main = "OLS (Heteroscedasticity)")
plot(model_wls, which = 3, main = "WLS (Standardized)")
w <- gavote$ballots/(percunder*(1-percunder))
model_wls <- update(modelbetter2, weights = w, data = gavote)
percunder
model_wls <- update(modelbetter2, weights = ballots, data = gavote)
summary(model_wls)
par(mfrow=c(1,2))
plot(modelbetter2, which = 3, main = "OLS (Heteroscedasticity)")
plot(model_wls, which = 3, main = "WLS (Standardized)")
#Clear the workspace
rm(list=ls())
library(faraway)
data(rock)
summary(rock)
pairs(rock, main="Scatterplot Matrix of Rock Data")
#Clear the workspace
rm(list=ls())
library(faraway)
library(MASS)
data(rock)
summary(rock)
pairs(rock, main="Scatterplot Matrix of Rock Data")
# Use Box-Cox to determine best transformation for perm
lmod <- lm(perm ~ area + peri + shape, data = rock)
bc <- boxcox(lmod, plotit = TRUE)
# 3. Identify the exact lambda that maximizes the log-likelihood
lambda <- bc$x[which.max(bc$y)]
print(lambda)
View(bc)
# Compare Base Model vs. Log-Transformed Model
lmod_full <- lm(perm ~ area + peri + shape, data = rock)
lmod_log  <- lm(log(perm) ~ area + peri + shape, data = rock)
# Compare Base Model vs. Log-Transformed Model
lmod_full <- lm(perm ~ area + peri + shape, data = rock)
lmod_log  <- lm(log(perm) ~ area + peri + shape, data = rock)
par(mfrow=c(1,2))
plot(lmod_full, which=1, main="Original Scale")
plot(lmod_log, which=1, main="Log Scale")
# Compare Base Model vs. Log-Transformed Model
lmod_full <- lm(perm ~ area + peri + shape, data = rock)
lmod_log  <- lm((perm)^(0.22) ~ area + peri + shape, data = rock)
par(mfrow=c(1,2))
plot(lmod_full, which=1, main="Original Scale")
plot(lmod_log, which=1, main="Log Scale")
# Compare Base Model vs. Log-Transformed Model
lmod_full <- lm(perm ~ area + peri + shape, data = rock)
lmod_log  <- lm(log(perm) ~ area + peri + shape, data = rock)
par(mfrow=c(1,2))
plot(lmod_full, which=1, main="Original Scale")
plot(lmod_log, which=1, main="Log Scale")
# Compare Base Model vs. Log-Transformed Model
full_model <- lm(perm ~ area + peri + shape, data = rock)
log_model  <- lm(log(perm) ~ area + peri + shape, data = rock)
par(mfrow=c(1,2))
plot(lmod_full, which=1, main="Original Scale")
plot(log_model, which=1, main="Log Scale")
best_mod <- step(log_model, direction = "both")
best_mod <- step(log_model, direction = "both")
summary(best_mod)
par(mfrow=c(2,2))
plot(best_mod)
